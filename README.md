## Техническое задание
## Задача 1 по анализу алгоритма
Insertion-Sort(A)
1 for j :=2 to length[A]
2 do key := A[j]
3 i :=j - 1
4 while i > 0 and A[i] > key
5 do A[i + 1] :=A[i]
6 i :=i - 1
7 A[i + 1] := key
Опишите работу представленного выше алгоритма.
Достаточно составить таблицу, где для каждой итерации цикла по переменной j будет представлена строка с указанием порядка перемещений для каждого элемента.
## Задача по написанию алгоритма вставки в список
В связанном списке элементы линейно упорядочены, но порядок определяется не номерами, как в массиве, а указателями, входящими в состав элементов списка. Списки являются удобным способом реализации динамических множеств, позволяющим реализовать все операции, необходимые для работы с данными. Другими словами элемент двухстороннего связанного списка – это запись содержащая три поля Key (Ключ) и два указателя Next(Следующий) и prev (Предыдущий ) Помимо этого, элементы списка могут содержать дополнительные данные. Если х-Элемент списка То next[x]. Указывает на следующий элемент списка, а prev[x] – на предшествующий. Если prev[x]=NIL, то у элемента x нет предшествующего: это голова(Head) списка. Если next[x]=NIL, то x - последний элемент списка или, как говорят его хвост (tail)
Прежде чем двигаться по указателям, надо знать хотя бы один элемент списка: мы предполагаем, что для списка L известен указатель head[L] на его голову. Если head[L]=NIL, то список пуст.
Для примера дана процедура поиска по списку:
Алгоритм поиска
List-Search(L; k)
1 x :=head[L]
2 while x != nil and key[x] != k
3 do x :=next[x]
4 return x
Если забыть о ситуации, когда удаляется 1 или последний элемент списка то алгоритм удаления может быть записан в виде
List-Delete(L; x)
1 next[prev[x]]:=next[x]
2 prev[next[x]]:= prev[x]
Напишите процедуру вставки элемента в голову списка.
Учесть, что элемент списка может быть пустым.
Декларация вызова:
List-Insert(L; x)
(L – указатель на список, x-указатель на элемент списка)
## Задача по распределению сумм.
Товарная позиция документа содержит три поля: количество, цена и сумма. Детализация товарной позиции документа содержит распределение количеств и сумм по людям. Количества в детализации вводятся вручную, суммы вычисляются автоматически.
Точность округления сумм – 2 знака, количества – 10 знаков.
Пример:
Товарная позиция Номенклатура Количество(кг) Цена Сумма(руб.)
Сахарный песок
58,21942216
10
582,19
Детализация Фамилия Количество(кг) Округленное Количество*Цену Распределение копеек Сумма
Иванов
30,88848888
308,88000000
0,02
308,90000000
Петров
5,88848888
58,88000000
0,01
58,89000000
Сидоров
5,88848888
58,88000000
0
58,88000000
Малевин
5,88848888
58,88000000
58,88000000
Макаров
5,88848888
58,88000000
58,88000000
Сетченко
1,88848888
Козлов
1,88848888
Итого
58,21942216
582,16000000
582,19000000
Примечание: серым курсивом отображены служебные поля, демонстрирующие расхождения по копейкам, а также корректный разброс суммарного расхождения по позициям.
Необходимо вычислить суммы по позициям разбрасывая итоговые расхождения по копейкам при округлении, пропорционально количеству в позиции.
Задача:
• Вычислить значение колонок «Округленное Количество*Цену», «Сумма» и «Распределение копеек» для «Сетченко» и «Козлова»
• Написать формулы, по которой вычисляется колонка «Распределение копеек», для Иванова, Петрова, Сидорова.
• Найти формулу, по которой вычисляется колонка «Сумма».
• Написать общий алгоритм вычисления по детализации
